use crate::config::Config;
use crate::generators::systemd::path_to_unit_name;

/// Generate btrbk.conf content
pub fn generate_config(config: &Config) -> String {
    let mut lines = Vec::new();

    lines.push("# /etc/btrbk/btrbk.conf".to_string());
    lines.push("# Generated by wslarc".to_string());
    lines.push(String::new());

    // Global settings
    lines.push("# Global settings".to_string());
    lines.push("transaction_log         /var/log/btrbk.log".to_string());
    lines.push("lockfile                /var/lock/btrbk.lock".to_string());
    lines.push("timestamp_format        long".to_string());
    lines.push(String::new());

    // Snapshot preserve policy
    lines.push("# Snapshot preserve policy".to_string());
    lines.push(format!(
        "snapshot_preserve_min   {}",
        config.btrbk.preserve_min
    ));
    lines.push(format!("snapshot_preserve       {}", config.btrbk.preserve));
    lines.push(String::new());

    // Volume configuration
    lines.push(format!("volume {}", config.mount.base));
    lines.push(format!("  snapshot_dir {}", config.btrbk.snapshot_dir));
    lines.push(String::new());

    // A-class subvolumes (backup targets)
    lines.push("  # A-class: Backup targets".to_string());
    for subvol in config.subvolumes.backup.keys() {
        let name = subvol.trim_start_matches('@');
        lines.push(format!("  subvolume {}", subvol));
        lines.push(format!("    snapshot_name {}", name));
        lines.push(String::new());
    }

    // @etc: snapshot-only (not mounted, but still snapshotted)
    lines.push("  # @etc: snapshot-only (not mounted to /etc)".to_string());
    lines.push("  subvolume @etc".to_string());
    lines.push("    snapshot_name etc".to_string());
    lines.push(String::new());

    // Note about excluded subvolumes
    lines.push("# B-class nested subvolumes are automatically excluded".to_string());
    lines.push("# C-class transfer subvolumes are not snapshotted".to_string());

    lines.join("\n")
}

/// Generate btrbk.service content
pub fn generate_service(config: &Config) -> String {
    let base_mount_unit = format!("{}.mount", path_to_unit_name(&config.mount.base));

    format!(
        r#"[Unit]
Description=btrbk Btrfs Snapshot Backup
Requires={base_mount_unit}
After={base_mount_unit}

[Service]
Type=oneshot
ExecStart=/usr/bin/btrbk -q run
Nice=19
IOSchedulingClass=idle
"#
    )
}

/// Generate btrbk.timer content
pub fn generate_timer(schedule: &str) -> String {
    format!(
        r#"[Unit]
Description=btrbk Daily Snapshot Timer

[Timer]
OnCalendar={}
RandomizedDelaySec=30min
Persistent=true

[Install]
WantedBy=timers.target
"#,
        schedule
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{
        BackupSubvol, BtrbkConfig, Config, ExcludeConfig, Ext4SyncConfig, MountConfig,
        SubvolumesConfig, UserConfig, VhdxConfig,
    };
    use std::collections::HashMap;

    fn test_config() -> Config {
        let mut backup = HashMap::new();
        backup.insert(
            "@home".to_string(),
            BackupSubvol::Simple("/home/testuser".to_string()),
        );
        backup.insert("@usr".to_string(), BackupSubvol::Simple("/usr".to_string()));

        Config {
            vhdx: VhdxConfig {
                path: r"C:\Users\test\.local\share\wsl\btrfs.vhdx".to_string(),
                label: "TestBtrfs".to_string(),
            },
            user: UserConfig {
                name: "testuser".to_string(),
                options: "-M -G wheel".to_string(),
            },
            mount: MountConfig {
                base: "/mnt/btrfs".to_string(),
                options: "compress=zstd:3,noatime,nofail".to_string(),
            },
            subvolumes: SubvolumesConfig {
                backup,
                exclude: ExcludeConfig {
                    parent: "@home".to_string(),
                    paths: vec![".cache".to_string()],
                },
                transfer: HashMap::new(),
            },
            btrbk: BtrbkConfig {
                snapshot_dir: ".snapshots".to_string(),
                preserve_min: "2d".to_string(),
                preserve: "14d 4w 2m".to_string(),
                timer_schedule: "*-*-* 03:00:00".to_string(),
            },
            ext4_sync: Ext4SyncConfig::default(),
            uuid: Some("12345678-1234-1234-1234-123456789abc".to_string()),
        }
    }

    #[test]
    fn test_generate_config() {
        let cfg = test_config();
        let output = generate_config(&cfg);

        assert!(output.contains("# /etc/btrbk/btrbk.conf"));
        assert!(output.contains("volume /mnt/btrfs"));
        assert!(output.contains("snapshot_dir .snapshots"));
        assert!(output.contains("snapshot_preserve_min   2d"));
        assert!(output.contains("snapshot_preserve       14d 4w 2m"));
        assert!(output.contains("subvolume @etc"));
    }

    #[test]
    fn test_generate_config_includes_backup_subvols() {
        let cfg = test_config();
        let output = generate_config(&cfg);

        assert!(output.contains("subvolume @home") || output.contains("subvolume @usr"));
    }

    #[test]
    fn test_generate_service() {
        let cfg = test_config();
        let output = generate_service(&cfg);

        assert!(output.contains("[Unit]"));
        assert!(output.contains("[Service]"));
        assert!(output.contains("ExecStart=/usr/bin/btrbk -q run"));
        assert!(output.contains(".mount"));
    }

    #[test]
    fn test_generate_timer() {
        let output = generate_timer("*-*-* 03:00:00");

        assert!(output.contains("[Unit]"));
        assert!(output.contains("[Timer]"));
        assert!(output.contains("[Install]"));
        assert!(output.contains("OnCalendar=*-*-* 03:00:00"));
        assert!(output.contains("Persistent=true"));
        assert!(output.contains("WantedBy=timers.target"));
    }
}
